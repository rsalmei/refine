use regex::Regex;
use std::sync::LazyLock;

/// Split the name, sequence, and (future) the alias from collection media names.
pub fn collection_parts(stem: &str) -> (&str, Option<usize>) {
    // static RE: LazyLock<Regex> =
    //     LazyLock::new(|| Regex::new(r"^(?<n>[^ ]*) \((?<a>.*)\)$").unwrap());

    let seq = Sequence::from(stem);
    let name = &stem[..seq.true_len];
    // let (name, alias) = match RE.captures(name).map(|caps| caps.extract()) {
    //     Some((name, [alias])) => (name, alias),
    //     _ => (name, ""),
    // };
    (name, seq.num)
}

#[derive(Debug)]
pub struct Sequence {
    pub num: Option<usize>,
    pub true_len: usize,
}

impl<S: AsRef<str>> From<S> for Sequence {
    fn from(stem: S) -> Self {
        static RE: LazyLock<Regex> =
            LazyLock::new(|| Regex::new(r"(?:[- ]+(\d+)| copy (\d+)| \((\d+)\))$").unwrap());

        let stem = stem.as_ref();
        let (len, num) = if let Some((full, [seq])) = RE.captures(stem).map(|caps| caps.extract()) {
            (full.len(), seq.parse().ok()) // regex checked.
        } else if stem.ends_with(" copy") {
            (5, Some(2)) // macOS first "Keep both files" when moving has no sequence (see also the test).
        } else {
            (0, None)
        };
        let true_len = stem.len() - len;
        Sequence { num, true_len }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn split_collection_parts() {
        #[track_caller]
        fn case(stem: &str, out: (&str, Option<usize>)) {
            assert_eq!(out, collection_parts(stem))
        }

        case("foo", ("foo", None));
        case("foo bar", ("foo bar", None));
        case("foo bar - baz", ("foo bar - baz", None));
        case("foo - 2025 - baz", ("foo - 2025 - baz", None));
        case("foo-1.bar-2-baz", ("foo-1.bar", None));

        case("foo-11", ("foo", Some(11)));
        case("foo - bar - 22", ("foo", Some(22)));
        case("foo - 2025 - 33", ("foo", Some(33)));
        case("foo - 2025", ("foo", Some(2025)));
        case("foo-1.bar-2", ("foo-1.bar", Some(2)));
    }

    #[test]
    fn extract_sequence() {
        #[track_caller]
        fn case(stem: &str, seq: impl Into<Option<usize>>, true_len: usize) {
            let s = Sequence::from(stem);
            assert_eq!(s.num, seq.into());
            assert_eq!(s.true_len, true_len);
        }

        // no sequence is found.
        case("foo", None, 3);
        case("foo123", None, 6);
        case("foo-bar", None, 7);
        case("foo-bar123", None, 10);
        case("foo-123 bar", None, 11);
        case("foo - bar", None, 9);
        case("foo(bar)", None, 8);
        case("foo (bar)", None, 9);

        // sequence is found, standard.
        case("foo-45678", 45678, 3); // the sequence style used here.
        case("foo2 123", 123, 4); // macOS "Keep both files" when copying.
        case("foo-bar copy", 2, 7); // macOS first "Keep both files" when moving.
        case("foo copy 18", 18, 3); // macOS from second onward when moving.
        case("foobar (9876)", 9876, 6); // Windows.

        // sequence is found, odd.
        case("foo -42", 42, 3);
        case("foo- 42", 42, 3);
        case("foo - 42", 42, 3);
        case("foo---42", 42, 3);
        case("foo -- 42", 42, 3);
        case("foo-- 42", 42, 3);
        case("foo --42", 42, 3);
        case("foo - - 42", 42, 3);

        // not actually generated by OSs but supported.
        case("f-o-o 1", 1, 5); // macOS doesn't generate "1".
        case("foo copy 1", 1, 3); // macOS doesn't generate "copy 1".
        case("foo (1)", 1, 3); // Windows doesn't generate "1".
    }
}
